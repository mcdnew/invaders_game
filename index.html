<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SPACE INVADERS ULTRA</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      color: #0f0;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      font-size: 20px;
      font-weight: bold;
      text-shadow: 2px 2px #000;
      z-index: 10;
      color: #0f0;
    }
    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.9);
      z-index: 20;
    }
    #overlay.hidden {
      display: none;
    }
    #overlay .panel {
      text-align: center;
      padding: 40px;
      border: 4px solid #0f0;
      background: #000;
    }
    #overlay h1 {
      font-size: 48px;
      color: #0f0;
      margin-bottom: 20px;
      letter-spacing: 4px;
    }
    #overlay p {
      font-size: 18px;
      color: #0f0;
      margin-bottom: 30px;
      line-height: 1.6;
    }
    #overlay button {
      font-family: 'Courier New', monospace;
      font-size: 24px;
      padding: 15px 40px;
      background: #0f0;
      color: #000;
      border: none;
      cursor: pointer;
      font-weight: bold;
      letter-spacing: 2px;
    }
    #overlay button:hover {
      background: #0f0;
      box-shadow: 0 0 20px #0f0;
    }
    .wave-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: #ff0;
      text-shadow: 3px 3px #000, 0 0 20px #ff0;
      z-index: 15;
      animation: pulse 0.5s ease-in-out;
    }
    @keyframes pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div id="score">SCORE: 0</div>
    <div id="high">HI-SCORE: 0</div>
    <div id="lives">LIVES: 3</div>
    <div id="wave">WAVE: 1</div>
  </div>

  <div id="overlay">
    <div class="panel">
      <h1>SPACE INVADERS</h1>
      <h1>ULTRA</h1>
      <p>
        DESTROY ALL INVADERS!<br>
        ARROW KEYS OR WASD: MOVE<br>
        SPACE: FIRE<br><br>
        PRESS START TO BEGIN
      </p>
      <button id="startBtn">START GAME</button>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const overlay = document.getElementById('overlay');
      const startBtn = document.getElementById('startBtn');

      const UI = {
        score: document.getElementById('score'),
        high: document.getElementById('high'),
        lives: document.getElementById('lives'),
        wave: document.getElementById('wave')
      };

      const COLORS = {
        bg: '#000',
        player: '#0f0',
        enemy1: '#f00',
        enemy2: '#ff0',
        enemy3: '#f0f',
        bullet: '#0ff',
        enemyBullet: '#f00',
        star: '#444'
      };

      const config = {
        width: 800,
        height: 600,
        playerSpeed: 250,
        bulletSpeed: 400,
        enemyBulletSpeed: 200,
        enemyMoveSpeed: 30,
        enemyDropDistance: 20,
        fireRate: 0.3,
        enemyFireRate: 1.5,
        scoreKey: 'invaders-hiscore'
      };

      const state = {
        playing: false,
        score: 0,
        highScore: 0,
        lives: 3,
        wave: 1,
        waveText: null,
        waveTextTimer: 0
      };

      const player = {
        x: 400,
        y: 550,
        width: 30,
        height: 20,
        fireTimer: 0
      };

      const keys = new Set();
      const bullets = [];
      const enemyBullets = [];
      const enemies = [];
      const explosions = [];
      const stars = [];

      // Audio
      const audio = (() => {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        let ctx = null;
        let master = null;

        function init() {
          if (!Ctx || ctx) return;
          ctx = new Ctx();
          master = ctx.createGain();
          master.gain.value = 0.15;
          master.connect(ctx.destination);
        }

        function play(freq, duration, type = 'square') {
          if (!ctx) return;
          const now = ctx.currentTime;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = type;
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0.3, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
          osc.connect(gain);
          gain.connect(master);
          osc.start(now);
          osc.stop(now + duration);
        }

        return {
          init,
          shoot() { play(400, 0.1, 'square'); },
          hit() { play(200, 0.15, 'sawtooth'); },
          explosion() { play(100, 0.3, 'triangle'); },
          death() { play(80, 0.5, 'triangle'); }
        };
      })();

      // Load high score
      try {
        state.highScore = parseInt(localStorage.getItem(config.scoreKey)) || 0;
      } catch (e) {}

      // Setup canvas
      canvas.width = config.width;
      canvas.height = config.height;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.maxWidth = config.width + 'px';
      canvas.style.maxHeight = config.height + 'px';
      canvas.style.margin = 'auto';
      canvas.style.display = 'block';

      // Create starfield
      for (let i = 0; i < 100; i++) {
        stars.push({
          x: Math.random() * config.width,
          y: Math.random() * config.height,
          size: Math.random() * 2
        });
      }

      // Input
      window.addEventListener('keydown', (e) => {
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
          e.preventDefault();
        }
        keys.add(e.code);
      });

      window.addEventListener('keyup', (e) => {
        keys.delete(e.code);
      });

      startBtn.addEventListener('click', () => {
        audio.init();
        overlay.classList.add('hidden');
        startGame();
      });

      document.addEventListener('keydown', () => audio.init(), { once: true });

      function startGame() {
        state.playing = true;
        state.score = 0;
        state.lives = 3;
        state.wave = 1;
        player.x = config.width / 2;
        player.y = config.height - 50;
        player.fireTimer = 0;
        bullets.length = 0;
        enemyBullets.length = 0;
        enemies.length = 0;
        explosions.length = 0;
        spawnWave();
        updateUI();
      }

      function spawnWave() {
        enemies.length = 0;
        enemyBullets.length = 0;

        const cols = 8;
        const rows = 4;
        const spacing = 60;
        const startX = (config.width - (cols - 1) * spacing) / 2;
        const startY = 80;

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const type = row === 0 ? 1 : row === 1 ? 2 : 3;
            enemies.push({
              x: startX + col * spacing,
              y: startY + row * spacing,
              width: 30,
              height: 20,
              type,
              fireTimer: Math.random() * 2,
              alive: true
            });
          }
        }

        // Show wave text
        showWaveText();
      }

      function showWaveText() {
        const div = document.createElement('div');
        div.className = 'wave-text';
        div.textContent = `WAVE ${state.wave}`;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 1500);
      }

      let lastTime = performance.now();
      let enemyDirection = 1;
      let enemyMoveTimer = 0;

      function gameLoop(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.1);
        lastTime = time;

        if (state.playing) {
          update(dt);
        }
        draw();
        requestAnimationFrame(gameLoop);
      }

      function update(dt) {
        // Player movement
        let dx = 0;
        if (keys.has('ArrowLeft') || keys.has('KeyA')) dx -= 1;
        if (keys.has('ArrowRight') || keys.has('KeyD')) dx += 1;
        player.x += dx * config.playerSpeed * dt;
        player.x = Math.max(player.width / 2, Math.min(config.width - player.width / 2, player.x));

        // Player shooting
        player.fireTimer = Math.max(0, player.fireTimer - dt);
        if (keys.has('Space') && player.fireTimer <= 0) {
          bullets.push({
            x: player.x,
            y: player.y - player.height / 2,
            width: 4,
            height: 12,
            vy: -config.bulletSpeed
          });
          player.fireTimer = config.fireRate;
          audio.shoot();
        }

        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          bullets[i].y += bullets[i].vy * dt;
          if (bullets[i].y < -20) {
            bullets.splice(i, 1);
            continue;
          }

          // Check collision with enemies
          for (const enemy of enemies) {
            if (!enemy.alive) continue;
            if (rectCollide(bullets[i], enemy)) {
              bullets.splice(i, 1);
              enemy.alive = false;
              createExplosion(enemy.x, enemy.y);
              audio.hit();
              const points = enemy.type === 1 ? 30 : enemy.type === 2 ? 20 : 10;
              state.score += points;
              if (state.score > state.highScore) {
                state.highScore = state.score;
                try {
                  localStorage.setItem(config.scoreKey, state.highScore);
                } catch (e) {}
              }
              updateUI();
              break;
            }
          }
        }

        // Move enemies
        enemyMoveTimer += dt;
        if (enemyMoveTimer >= 1.0 / (5 + state.wave * 0.5)) {
          enemyMoveTimer = 0;
          let hitEdge = false;

          for (const enemy of enemies) {
            if (!enemy.alive) continue;
            enemy.x += enemyDirection * config.enemyMoveSpeed;
            if (enemy.x < 30 || enemy.x > config.width - 30) {
              hitEdge = true;
            }
          }

          if (hitEdge) {
            enemyDirection *= -1;
            for (const enemy of enemies) {
              if (!enemy.alive) continue;
              enemy.y += config.enemyDropDistance;
              enemy.x += enemyDirection * config.enemyMoveSpeed;
            }
          }
        }

        // Enemy shooting
        for (const enemy of enemies) {
          if (!enemy.alive) continue;
          enemy.fireTimer -= dt;
          if (enemy.fireTimer <= 0) {
            enemy.fireTimer = config.enemyFireRate + Math.random() * 2;
            if (Math.random() < 0.3) {
              enemyBullets.push({
                x: enemy.x,
                y: enemy.y + enemy.height / 2,
                width: 4,
                height: 12,
                vy: config.enemyBulletSpeed
              });
            }
          }

          // Check if enemy reached bottom
          if (enemy.y > config.height - 100) {
            gameOver();
            return;
          }
        }

        // Update enemy bullets
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          enemyBullets[i].y += enemyBullets[i].vy * dt;
          if (enemyBullets[i].y > config.height + 20) {
            enemyBullets.splice(i, 1);
            continue;
          }

          // Check collision with player
          if (rectCollide(enemyBullets[i], {
            x: player.x,
            y: player.y,
            width: player.width,
            height: player.height
          })) {
            enemyBullets.splice(i, 1);
            playerHit();
          }
        }

        // Update explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
          explosions[i].life -= dt;
          if (explosions[i].life <= 0) {
            explosions.splice(i, 1);
          }
        }

        // Check if wave complete
        if (enemies.every(e => !e.alive)) {
          state.wave++;
          updateUI();
          setTimeout(() => spawnWave(), 2000);
        }
      }

      function playerHit() {
        state.lives--;
        updateUI();
        createExplosion(player.x, player.y);
        audio.death();

        if (state.lives <= 0) {
          gameOver();
        } else {
          // Brief invulnerability
          player.x = config.width / 2;
          enemyBullets.length = 0;
        }
      }

      function gameOver() {
        state.playing = false;
        overlay.querySelector('h1').textContent = 'GAME OVER';
        overlay.querySelector('p').innerHTML = `FINAL SCORE: ${state.score}<br>HI-SCORE: ${state.highScore}<br><br>PRESS START TO CONTINUE`;
        startBtn.textContent = 'CONTINUE';
        overlay.classList.remove('hidden');
      }

      function createExplosion(x, y) {
        for (let i = 0; i < 8; i++) {
          explosions.push({
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 20,
            size: 3 + Math.random() * 5,
            life: 0.5
          });
        }
      }

      function rectCollide(a, b) {
        return a.x < b.x + b.width &&
               a.x + a.width > b.x &&
               a.y < b.y + b.height &&
               a.y + a.height > b.y;
      }

      function updateUI() {
        UI.score.textContent = `SCORE: ${state.score}`;
        UI.high.textContent = `HI-SCORE: ${state.highScore}`;
        UI.lives.textContent = `LIVES: ${state.lives}`;
        UI.wave.textContent = `WAVE: ${state.wave}`;
      }

      function draw() {
        // Background
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, config.width, config.height);

        // Stars
        ctx.fillStyle = COLORS.star;
        for (const star of stars) {
          ctx.fillRect(star.x, star.y, star.size, star.size);
        }

        // Player
        ctx.fillStyle = COLORS.player;
        ctx.fillRect(player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);
        // Cockpit
        ctx.fillStyle = '#fff';
        ctx.fillRect(player.x - 5, player.y - 8, 10, 10);
        // Wings
        ctx.fillStyle = COLORS.player;
        ctx.fillRect(player.x - player.width / 2 - 5, player.y + 5, 8, 5);
        ctx.fillRect(player.x + player.width / 2 - 3, player.y + 5, 8, 5);

        // Bullets
        ctx.fillStyle = COLORS.bullet;
        for (const bullet of bullets) {
          ctx.fillRect(bullet.x - bullet.width / 2, bullet.y, bullet.width, bullet.height);
        }

        // Enemy bullets
        ctx.fillStyle = COLORS.enemyBullet;
        for (const bullet of enemyBullets) {
          ctx.fillRect(bullet.x - bullet.width / 2, bullet.y, bullet.width, bullet.height);
        }

        // Enemies
        for (const enemy of enemies) {
          if (!enemy.alive) continue;

          const color = enemy.type === 1 ? COLORS.enemy1 :
                       enemy.type === 2 ? COLORS.enemy2 : COLORS.enemy3;

          ctx.fillStyle = color;

          // Body
          ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);

          // Eyes
          ctx.fillStyle = '#000';
          ctx.fillRect(enemy.x - 8, enemy.y - 5, 5, 5);
          ctx.fillRect(enemy.x + 3, enemy.y - 5, 5, 5);

          // Antenna
          ctx.fillStyle = color;
          ctx.fillRect(enemy.x - 3, enemy.y - enemy.height / 2 - 8, 2, 8);
          ctx.fillRect(enemy.x + 1, enemy.y - enemy.height / 2 - 8, 2, 8);
        }

        // Explosions
        ctx.fillStyle = '#ff0';
        for (const exp of explosions) {
          ctx.globalAlpha = exp.life * 2;
          ctx.fillRect(exp.x - exp.size / 2, exp.y - exp.size / 2, exp.size, exp.size);
        }
        ctx.globalAlpha = 1;

        // Scanline effect
        ctx.fillStyle = 'rgba(0, 255, 0, 0.02)';
        for (let y = 0; y < config.height; y += 4) {
          ctx.fillRect(0, y, config.width, 2);
        }
      }

      updateUI();
      gameLoop(performance.now());
    })();
  </script>
</body>
</html>
